<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>삼국지 전략 시뮬레이션</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Malgun Gothic', sans-serif; background: #1a1a2e; color: #e0e0e0; overflow: hidden; }

        /* ===== Title Screen ===== */
        #title-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        #title-screen h1 {
            font-size: 52px; color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,0.5);
            margin-bottom: 8px; letter-spacing: 8px;
        }
        #title-screen .subtitle {
            font-size: 16px; color: #aaa; margin-bottom: 40px; letter-spacing: 4px;
        }
        .scenario-select { text-align: center; margin-bottom: 30px; }
        .scenario-select h3 { color: #ffd700; margin-bottom: 15px; font-size: 18px; }
        .scenario-btn {
            background: rgba(255,215,0,0.1); border: 1px solid #ffd700; color: #ffd700;
            padding: 10px 30px; border-radius: 6px; cursor: pointer; font-size: 14px;
            font-family: inherit; transition: all 0.3s;
        }
        .scenario-btn:hover { background: rgba(255,215,0,0.3); }
        .scenario-btn.active { background: rgba(255,215,0,0.3); box-shadow: 0 0 10px rgba(255,215,0,0.3); }

        .faction-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px;
            max-width: 700px; margin-bottom: 30px;
        }
        .faction-card {
            background: rgba(255,255,255,0.05); border: 2px solid #444;
            border-radius: 8px; padding: 12px; text-align: center; cursor: pointer;
            transition: all 0.3s;
        }
        .faction-card:hover { border-color: #ffd700; background: rgba(255,215,0,0.1); }
        .faction-card.selected { border-color: #ffd700; background: rgba(255,215,0,0.2); box-shadow: 0 0 15px rgba(255,215,0,0.3); }
        .faction-card .lord { font-size: 18px; font-weight: bold; margin-bottom: 4px; }
        .faction-card .cities { font-size: 11px; color: #aaa; }
        .faction-card .color-bar { height: 3px; border-radius: 2px; margin-top: 8px; }

        #start-btn {
            background: linear-gradient(135deg, #ffd700, #f0a500); border: none;
            color: #1a1a2e; padding: 14px 50px; border-radius: 8px; font-size: 18px;
            font-weight: bold; cursor: pointer; font-family: inherit;
            transition: all 0.3s; letter-spacing: 2px;
        }
        #start-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,0.5); }
        #start-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

        /* ===== Game Layout ===== */
        #game-screen { display: none; width: 100vw; height: 100vh; }

        /* Top Bar */
        #top-bar {
            height: 44px; background: rgba(15,15,30,0.95); border-bottom: 1px solid #333;
            display: flex; align-items: center; padding: 0 16px; z-index: 1000;
            position: relative;
        }
        #top-bar .turn-info { font-size: 15px; color: #ffd700; font-weight: bold; flex: 1; }
        #top-bar .turn-info .season { font-size: 12px; margin-left: 8px; padding: 2px 8px; border-radius: 4px; }
        .season-spring { background: #2e7d32; color: #a5d6a7; }
        .season-summer { background: #c62828; color: #ef9a9a; }
        .season-autumn { background: #e65100; color: #ffcc80; }
        .season-winter { background: #1565c0; color: #90caf9; }
        #top-bar .player-resources { display: flex; gap: 18px; margin-right: 16px; font-size: 13px; }
        #top-bar .player-resources span { color: #ccc; }
        #top-bar .player-resources .val { font-weight: bold; }
        .res-gold .val { color: #ffd700; }
        .res-food .val { color: #8bc34a; }
        .res-troops .val { color: #f44336; }
        .res-cities .val { color: #29b6f6; }
        #end-turn-btn {
            background: #c62828; border: none; color: #fff; padding: 6px 20px;
            border-radius: 4px; cursor: pointer; font-size: 13px; font-family: inherit;
            font-weight: bold; transition: background 0.2s;
        }
        #end-turn-btn:hover { background: #e53935; }
        #menu-btn {
            background: #444; border: none; color: #ccc; padding: 6px 14px;
            border-radius: 4px; cursor: pointer; font-size: 13px; font-family: inherit;
            margin-left: 8px; transition: background 0.2s;
        }
        #menu-btn:hover { background: #555; }

        /* Main Area */
        #main-area {
            display: flex; height: calc(100vh - 44px - 120px);
        }

        /* Left Panel - Faction Overview */
        #faction-panel {
            width: 220px; background: rgba(15,15,30,0.95); border-right: 1px solid #333;
            overflow-y: auto; padding: 12px; flex-shrink: 0;
        }
        #faction-panel h3 { color: #ffd700; font-size: 13px; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 6px; }
        .faction-row {
            display: flex; align-items: center; padding: 5px 4px; border-radius: 4px;
            margin-bottom: 2px; cursor: pointer; font-size: 12px; transition: background 0.2s;
        }
        .faction-row:hover { background: rgba(255,255,255,0.05); }
        .faction-row.current { background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); }
        .faction-row .f-color { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; flex-shrink: 0; }
        .faction-row .f-name { flex: 1; }
        .faction-row .f-stat { color: #888; font-size: 11px; }

        .faction-detail { margin-top: 12px; font-size: 11px; }
        .faction-detail h4 { color: #ffd700; margin-bottom: 6px; font-size: 12px; }
        .faction-detail .stat-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid #222; }
        .faction-detail .stat-label { color: #888; }
        .faction-detail .stat-val { color: #e0e0e0; }

        /* Map */
        #map { flex: 1; cursor: crosshair; }
        .leaflet-interactive { cursor: pointer !important; }

        .city-marker {
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 2px 6px rgba(0,0,0,0.6); transition: transform 0.15s;
            position: relative;
        }
        .city-marker:hover { transform: scale(1.3); }
        .city-marker.selected { border-color: #ffd700; box-shadow: 0 0 12px rgba(255,215,0,0.8); }
        .city-label-game {
            background: none !important; border: none !important; box-shadow: none !important;
            font-size: 11px; font-weight: bold; color: #fff;
            text-shadow: 2px 2px 3px #000, -1px -1px 2px #000, 1px -1px 2px #000, -1px 2px 2px #000;
            white-space: nowrap;
        }
        .troop-badge {
            background: none !important; border: none !important; box-shadow: none !important;
            font-size: 9px; color: #ffcdd2; white-space: nowrap;
            text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;
        }

        /* Right Panel - City Management */
        #city-panel {
            width: 280px; background: rgba(15,15,30,0.95); border-left: 1px solid #333;
            overflow-y: auto; padding: 14px; flex-shrink: 0;
        }
        #city-panel h3 { color: #ffd700; font-size: 15px; margin-bottom: 4px; }
        #city-panel .city-owner { font-size: 12px; margin-bottom: 10px; }
        .city-stats { margin-bottom: 12px; }
        .city-stat-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 4px 0; border-bottom: 1px solid #222; font-size: 12px;
        }
        .city-stat-row .label { color: #888; }
        .city-stat-row .value { font-weight: bold; }
        .stat-bar-bg {
            width: 80px; height: 6px; background: #333; border-radius: 3px; overflow: hidden;
        }
        .stat-bar { height: 100%; border-radius: 3px; transition: width 0.3s; }

        .action-section { margin-top: 12px; }
        .action-section h4 { color: #ffd700; font-size: 12px; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .action-btn {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; background: rgba(255,255,255,0.05); border: 1px solid #444;
            color: #e0e0e0; padding: 8px 12px; border-radius: 6px; cursor: pointer;
            font-size: 12px; font-family: inherit; margin-bottom: 6px; transition: all 0.2s;
        }
        .action-btn:hover:not(:disabled) { background: rgba(255,215,0,0.1); border-color: #ffd700; }
        .action-btn:disabled { opacity: 0.35; cursor: not-allowed; }
        .action-btn .cost { font-size: 10px; color: #aaa; }
        .action-btn .acted { font-size: 10px; color: #f44336; }
        .no-city-msg { color: #666; text-align: center; margin-top: 40px; font-size: 13px; }

        /* Bottom - Event Log */
        #event-log {
            height: 120px; background: rgba(10,10,25,0.95); border-top: 1px solid #333;
            overflow-y: auto; padding: 8px 14px; font-size: 11px;
        }
        #event-log .log-entry { padding: 2px 0; border-bottom: 1px solid #1a1a2e; }
        #event-log .log-turn { color: #ffd700; font-weight: bold; margin-right: 6px; }
        #event-log .log-text { color: #bbb; }
        #event-log .log-good { color: #66bb6a; }
        #event-log .log-bad { color: #ef5350; }
        #event-log .log-info { color: #42a5f5; }

        /* Popup overlay for Leaflet */
        .leaflet-popup-content-wrapper { background: rgba(30,30,30,0.95); color: #fff; border-radius: 8px; }
        .leaflet-popup-tip { background: rgba(30,30,30,0.95); }

        /* Menu overlay */
        #menu-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 5000;
            align-items: center; justify-content: center;
        }
        #menu-overlay.active { display: flex; }
        .menu-box {
            background: #1a1a2e; border: 1px solid #444; border-radius: 12px;
            padding: 30px; text-align: center; min-width: 300px;
        }
        .menu-box h2 { color: #ffd700; margin-bottom: 20px; }
        .menu-box button {
            display: block; width: 100%; background: rgba(255,255,255,0.05);
            border: 1px solid #444; color: #e0e0e0; padding: 12px; margin-bottom: 8px;
            border-radius: 6px; font-size: 14px; cursor: pointer; font-family: inherit;
            transition: all 0.2s;
        }
        .menu-box button:hover { background: rgba(255,215,0,0.1); border-color: #ffd700; }

        /* Turn transition overlay */
        #turn-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 4000;
            align-items: center; justify-content: center;
        }
        #turn-overlay.active { display: flex; }
        #turn-overlay .turn-msg {
            color: #ffd700; font-size: 28px; font-weight: bold;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        /* ===== Combat UI ===== */
        .action-btn.attack-btn {
            background: rgba(244,67,54,0.15); border-color: #f44336; color: #ff8a80;
        }
        .action-btn.attack-btn:hover:not(:disabled) {
            background: rgba(244,67,54,0.3); border-color: #ff5252;
        }

        .attack-target-panel { margin-top: 8px; }
        .attack-target-panel h4 { color: #f44336; font-size: 12px; margin-bottom: 6px; border-bottom: 1px solid #5a2020; padding-bottom: 4px; }
        .target-btn {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; background: rgba(244,67,54,0.08); border: 1px solid #5a2020;
            color: #e0e0e0; padding: 7px 10px; border-radius: 5px; cursor: pointer;
            font-size: 11px; font-family: inherit; margin-bottom: 4px; transition: all 0.2s;
        }
        .target-btn:hover { background: rgba(244,67,54,0.2); border-color: #f44336; }
        .target-btn .target-info { font-size: 10px; color: #aaa; }
        .target-btn.empty-city { border-color: #8d6e00; background: rgba(255,215,0,0.08); }
        .target-btn.empty-city:hover { background: rgba(255,215,0,0.2); border-color: #ffd700; }

        .troop-slider-section { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px; }
        .troop-slider-section label { font-size: 12px; color: #ccc; display: block; margin-bottom: 6px; }
        .troop-slider-section input[type="range"] { width: 100%; margin: 4px 0; accent-color: #f44336; }
        .troop-slider-section .slider-info { display: flex; justify-content: space-between; font-size: 11px; color: #aaa; }
        .confirm-attack-btn {
            width: 100%; margin-top: 8px; padding: 8px; background: #c62828; border: none;
            color: #fff; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: bold;
            font-family: inherit; transition: background 0.2s;
        }
        .confirm-attack-btn:hover { background: #e53935; }
        .cancel-attack-btn {
            width: 100%; margin-top: 4px; padding: 6px; background: rgba(255,255,255,0.05);
            border: 1px solid #444; color: #aaa; border-radius: 5px; cursor: pointer;
            font-size: 11px; font-family: inherit; transition: all 0.2s;
        }
        .cancel-attack-btn:hover { background: rgba(255,255,255,0.1); }

        /* Battle Result Popup */
        #battle-popup {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); z-index: 6000;
            align-items: center; justify-content: center;
        }
        #battle-popup.active { display: flex; }
        .battle-box {
            background: #1a1a2e; border: 2px solid #c62828; border-radius: 12px;
            padding: 24px 30px; text-align: center; min-width: 320px; max-width: 420px;
            box-shadow: 0 0 40px rgba(198,40,40,0.4);
        }
        .battle-box.victory { border-color: #ffd700; box-shadow: 0 0 40px rgba(255,215,0,0.4); }
        .battle-box h2 { font-size: 22px; margin-bottom: 12px; }
        .battle-box .battle-detail { font-size: 12px; color: #bbb; text-align: left; line-height: 1.8; margin: 12px 0; }
        .battle-box .battle-detail .att { color: #ff8a80; }
        .battle-box .battle-detail .def { color: #90caf9; }
        .battle-box button {
            margin-top: 12px; padding: 8px 30px; background: #444; border: none; color: #fff;
            border-radius: 6px; cursor: pointer; font-size: 14px; font-family: inherit;
        }
        .battle-box button:hover { background: #555; }

        /* Victory / Game Over Overlay */
        #victory-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 7000;
            align-items: center; justify-content: center;
        }
        #victory-overlay.active { display: flex; }
        .victory-box {
            text-align: center; padding: 40px;
        }
        .victory-box h1 { font-size: 42px; margin-bottom: 12px; text-shadow: 0 0 30px currentColor; }
        .victory-box p { font-size: 16px; color: #ccc; margin-bottom: 24px; }
        .victory-box button {
            padding: 12px 40px; background: linear-gradient(135deg, #ffd700, #f0a500); border: none;
            color: #1a1a2e; font-size: 16px; font-weight: bold; border-radius: 8px; cursor: pointer;
            font-family: inherit;
        }
        .victory-box button:hover { transform: scale(1.05); }

        /* ===== Officer System ===== */
        .officer-section { margin-top: 12px; margin-bottom: 8px; }
        .officer-header { color: #ffd700; font-size: 12px; margin-bottom: 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .no-officer { color: #666; font-size: 11px; text-align: center; padding: 6px 0; }
        .officer-card {
            background: rgba(255,255,255,0.03); border: 1px solid #333; border-radius: 5px;
            padding: 6px 8px; margin-bottom: 4px; transition: border-color 0.2s;
        }
        .officer-card:hover { border-color: #555; }
        .officer-name { font-size: 12px; font-weight: bold; color: #e0e0e0; }
        .officer-chinese { font-size: 10px; color: #888; font-weight: normal; }
        .officer-stats {
            display: flex; gap: 6px; margin-top: 3px; font-size: 10px;
        }
        .os-war { color: #ff8a80; }
        .os-int { color: #82b1ff; }
        .os-pol { color: #b9f6ca; }
        .os-cha { color: #ffe082; }
        .officer-move { display: flex; flex-wrap: wrap; gap: 3px; margin-top: 4px; }
        .officer-move-btn {
            background: rgba(255,215,0,0.08); border: 1px solid #555; color: #ccc;
            padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;
            font-family: inherit; transition: all 0.2s;
        }
        .officer-move-btn:hover { background: rgba(255,215,0,0.2); border-color: #ffd700; color: #ffd700; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a2e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>

<!-- ===== Title Screen ===== -->
<div id="title-screen">
    <h1>三國志</h1>
    <div class="subtitle">전략 시뮬레이션</div>

    <div class="scenario-select">
        <h3>시나리오</h3>
        <button class="scenario-btn active" data-scenario="190">190년 - 반동탁 연합</button>
    </div>

    <div class="faction-grid" id="faction-grid"></div>

    <button id="start-btn" disabled onclick="startGame()">게임 시작</button>
</div>

<!-- ===== Game Screen ===== -->
<div id="game-screen">
    <!-- Top Bar -->
    <div id="top-bar">
        <div class="turn-info">
            <span id="turn-date">190년 1월</span>
            <span id="turn-season" class="season season-winter">겨울</span>
        </div>
        <div class="player-resources">
            <span class="res-gold">금 <span class="val" id="res-gold">0</span></span>
            <span class="res-food">식량 <span class="val" id="res-food">0</span></span>
            <span class="res-troops">병력 <span class="val" id="res-troops">0</span></span>
            <span class="res-cities">도시 <span class="val" id="res-cities">0</span></span>
        </div>
        <button id="end-turn-btn" onclick="endTurn()">턴 종료</button>
        <button id="menu-btn" onclick="toggleMenu()">메뉴</button>
    </div>

    <!-- Main Area -->
    <div id="main-area">
        <!-- Left: Faction Panel -->
        <div id="faction-panel">
            <h3>세력 정보</h3>
            <div id="faction-list"></div>
            <div id="faction-detail" class="faction-detail"></div>
        </div>

        <!-- Center: Map -->
        <div id="map"></div>

        <!-- Right: City Panel -->
        <div id="city-panel">
            <div class="no-city-msg" id="no-city-msg">도시를 클릭하여<br>정보를 확인하세요</div>
            <div id="city-info" style="display:none"></div>
        </div>
    </div>

    <!-- Bottom: Event Log -->
    <div id="event-log">
        <div class="log-entry"><span class="log-turn">[시스템]</span><span class="log-text">게임을 시작합니다...</span></div>
    </div>
</div>

<!-- Menu Overlay -->
<div id="menu-overlay">
    <div class="menu-box">
        <h2>메뉴</h2>
        <button onclick="toggleMenu()">게임으로 돌아가기</button>
        <button onclick="location.reload()">타이틀로 돌아가기</button>
    </div>
</div>

<!-- Turn Transition Overlay -->
<div id="turn-overlay">
    <div class="turn-msg" id="turn-msg"></div>
</div>

<!-- Battle Result Popup -->
<div id="battle-popup">
    <div class="battle-box" id="battle-box"></div>
</div>

<!-- Victory / Game Over Overlay -->
<div id="victory-overlay">
    <div class="victory-box" id="victory-box"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="three-kingdoms-data.js"></script>
<script>
// ============================================================
// GAME DATA CONSTANTS
// ============================================================

const GAME_CITIES = [
    // 유주
    { id: "bukpyeong", name: "北平", korean: "북평", region: "유주", lat: 39.90, lng: 116.40 },
    { id: "gye", name: "蓟", korean: "계", region: "유주", lat: 39.70, lng: 116.10 },
    // 병주
    { id: "jinyang", name: "晋阳", korean: "진양", region: "병주", lat: 37.87, lng: 112.55 },
    { id: "sangdang", name: "上党", korean: "상당", region: "병주", lat: 36.12, lng: 113.12 },
    // 기주
    { id: "eop", name: "邺", korean: "업", region: "기주", lat: 36.34, lng: 114.62 },
    { id: "nampi", name: "南皮", korean: "남피", region: "기주", lat: 38.37, lng: 116.70 },
    { id: "pyeongwon", name: "平原", korean: "평원", region: "기주", lat: 37.38, lng: 116.62 },
    // 청주
    { id: "imchi", name: "临淄", korean: "임치", region: "청주", lat: 36.70, lng: 118.48 },
    { id: "bukhae", name: "北海", korean: "북해", region: "청주", lat: 36.78, lng: 119.17 },
    // 연주
    { id: "jinryu", name: "陈留", korean: "진류", region: "연주", lat: 34.85, lng: 114.35 },
    { id: "bokyang", name: "濮阳", korean: "복양", region: "연주", lat: 35.76, lng: 115.03 },
    { id: "sanyang", name: "山阳", korean: "산양", region: "연주", lat: 35.40, lng: 116.30 },
    { id: "taesan", name: "泰山", korean: "태산", region: "연주", lat: 36.00, lng: 117.05 },
    // 서주
    { id: "paengseong", name: "彭城", korean: "팽성", region: "서주", lat: 34.26, lng: 117.19 },
    { id: "habi", name: "下邳", korean: "하비", region: "서주", lat: 34.32, lng: 117.95 },
    { id: "sopae", name: "小沛", korean: "소패", region: "서주", lat: 34.72, lng: 116.93 },
    { id: "gwangneung", name: "广陵", korean: "광릉", region: "서주", lat: 32.39, lng: 119.43 },
    { id: "nangya", name: "琅琊", korean: "낭야", region: "서주", lat: 35.10, lng: 118.35 },
    { id: "donghae", name: "东海", korean: "동해", region: "서주", lat: 34.55, lng: 118.70 },
    // 예주
    { id: "heochang", name: "许昌", korean: "허창", region: "예주", lat: 34.02, lng: 113.85 },
    { id: "yeonam", name: "汝南", korean: "여남", region: "예주", lat: 33.00, lng: 114.35 },
    { id: "suchun", name: "寿春", korean: "수춘", region: "예주", lat: 32.57, lng: 116.78 },
    { id: "cho", name: "谯", korean: "초", region: "예주", lat: 33.88, lng: 115.78 },
    { id: "yeoeum", name: "汝阴", korean: "여음", region: "예주", lat: 33.40, lng: 115.80 },
    { id: "wan", name: "宛", korean: "완", region: "예주", lat: 33.00, lng: 112.53 },
    { id: "namyang", name: "南阳", korean: "남양", region: "예주", lat: 33.26, lng: 112.53 },
    // 사예
    { id: "nakyang", name: "洛阳", korean: "낙양", region: "사예", lat: 34.62, lng: 112.45 },
    { id: "jangan", name: "长安", korean: "장안", region: "사예", lat: 34.27, lng: 108.95 },
    // 양주(량)
    { id: "cheonsu", name: "天水", korean: "천수", region: "양주(량)", lat: 34.58, lng: 105.90 },
    { id: "muwi", name: "武威", korean: "무위", region: "양주(량)", lat: 37.93, lng: 102.63 },
    { id: "anjeong", name: "安定", korean: "안정", region: "양주(량)", lat: 35.55, lng: 106.68 },
    // 형주
    { id: "yangyang", name: "襄阳", korean: "양양", region: "형주", lat: 32.01, lng: 112.13 },
    { id: "gangneung", name: "江陵", korean: "강릉", region: "형주", lat: 30.35, lng: 112.24 },
    { id: "gangha", name: "江夏", korean: "강하", region: "형주", lat: 30.58, lng: 114.30 },
    { id: "jangsa", name: "长沙", korean: "장사", region: "형주", lat: 28.19, lng: 113.00 },
    { id: "gyeyang", name: "桂阳", korean: "계양", region: "형주", lat: 25.78, lng: 113.05 },
    { id: "yeongneung", name: "零陵", korean: "영릉", region: "형주", lat: 26.23, lng: 111.62 },
    { id: "mureung", name: "武陵", korean: "무릉", region: "형주", lat: 29.05, lng: 111.70 },
    { id: "sinya", name: "新野", korean: "신야", region: "형주", lat: 32.52, lng: 112.42 },
    { id: "sangyong", name: "上庸", korean: "상용", region: "형주", lat: 32.22, lng: 110.23 },
    // 익주
    { id: "seongdo", name: "成都", korean: "성도", region: "익주", lat: 30.67, lng: 104.07 },
    { id: "hanjung", name: "汉中", korean: "한중", region: "익주", lat: 33.07, lng: 107.03 },
    { id: "jaedong", name: "梓潼", korean: "재동", region: "익주", lat: 31.64, lng: 105.17 },
    { id: "nangjung", name: "阆中", korean: "낭중", region: "익주", lat: 31.58, lng: 105.97 },
    { id: "gangju", name: "江州", korean: "강주", region: "익주", lat: 29.56, lng: 106.55 },
    { id: "yeongan", name: "永安", korean: "영안", region: "익주", lat: 31.02, lng: 109.46 },
    { id: "geonnyeong", name: "建宁", korean: "건녕", region: "익주", lat: 25.05, lng: 102.70 },
    { id: "yeongchang", name: "永昌", korean: "영창", region: "익주", lat: 25.04, lng: 98.50 },
    { id: "unnam", name: "云南", korean: "운남", region: "익주", lat: 25.52, lng: 100.58 },
    // 양주(양)
    { id: "geonup", name: "建业", korean: "건업", region: "양주", lat: 32.06, lng: 118.80 },
    { id: "ogun", name: "吴郡", korean: "오군", region: "양주", lat: 31.30, lng: 120.62 },
    { id: "hoegye", name: "会稽", korean: "회계", region: "양주", lat: 30.00, lng: 120.58 },
    { id: "sisang", name: "柴桑", korean: "시상", region: "양주", lat: 29.73, lng: 115.99 },
    { id: "yeogang", name: "庐江", korean: "여강", region: "양주", lat: 30.95, lng: 117.32 },
    { id: "yejang", name: "豫章", korean: "예장", region: "양주", lat: 28.68, lng: 115.90 },
    // 교주
    { id: "beonu", name: "番禺", korean: "번우", region: "교주", lat: 23.13, lng: 113.27 },
    { id: "gyoji", name: "交趾", korean: "교지", region: "교주", lat: 22.82, lng: 108.32 },
];

const FACTIONS = {
    dongtak: { name: "동탁", chinese: "董卓", color: "#8e24aa", desc: "낙양의 폭군" },
    jojo: { name: "조조", chinese: "曹操", color: "#1e88e5", desc: "난세의 간웅" },
    yubi: { name: "유비", chinese: "刘备", color: "#43a047", desc: "인덕의 군주" },
    songyeon: { name: "손견", chinese: "孙坚", color: "#e53935", desc: "강동의 맹호" },
    wonso: { name: "원소", chinese: "袁绍", color: "#fdd835", desc: "하북의 명문" },
    yupyo: { name: "유표", chinese: "刘表", color: "#ff8f00", desc: "형주의 수성자" },
    yujang: { name: "유장", chinese: "刘璋", color: "#00897b", desc: "익주의 암우" },
    madeung: { name: "마등", chinese: "马腾", color: "#6d4c41", desc: "서량의 철기" },
    gongsonchan: { name: "공손찬", chinese: "公孙瓒", color: "#78909c", desc: "백마의 장군" },
    wonsul: { name: "원술", chinese: "袁术", color: "#ab47bc", desc: "회남의 야심가" },
};

// 190년 시나리오: owner 할당 (null = 공백)
const SCENARIO_190 = {
    year: 190, month: 1,
    cityOwners: {
        // 동탁: 낙양, 장안
        nakyang: "dongtak", jangan: "dongtak",
        // 조조: 진류
        jinryu: "jojo",
        // 유비: 평원
        pyeongwon: "yubi",
        // 손견: 장사
        jangsa: "songyeon",
        // 원소: 남피
        nampi: "wonso",
        // 유표: 양양, 강릉, 강하, 무릉
        yangyang: "yupyo", gangneung: "yupyo", gangha: "yupyo", mureung: "yupyo",
        // 유장: 성도, 한중, 재동, 낭중, 강주, 영안, 건녕, 영창, 운남
        seongdo: "yujang", hanjung: "yujang", jaedong: "yujang", nangjung: "yujang",
        gangju: "yujang", yeongan: "yujang", geonnyeong: "yujang", yeongchang: "yujang", unnam: "yujang",
        // 마등: 무위, 천수
        muwi: "madeung", cheonsu: "madeung",
        // 공손찬: 북평, 계
        bukpyeong: "gongsonchan", gye: "gongsonchan",
        // 원술: 수춘, 여남
        suchun: "wonsul", yeonam: "wonsul",
    },
    // 기본 도시 스탯 오버라이드 (수도급 도시)
    cityStats: {
        nakyang: { population: 350000, gold: 20000, food: 3000000, troops: 20000, development: 80, commerce: 75, defense: 70, loyalty: 40 },
        jangan: { population: 300000, gold: 18000, food: 2500000, troops: 15000, development: 75, commerce: 70, defense: 65, loyalty: 45 },
        seongdo: { population: 280000, gold: 18000, food: 3500000, troops: 12000, development: 70, commerce: 65, defense: 60, loyalty: 70 },
        yangyang: { population: 200000, gold: 14000, food: 2500000, troops: 10000, development: 65, commerce: 60, defense: 55, loyalty: 65 },
        geonup: { population: 220000, gold: 14000, food: 2200000, troops: 5000, development: 60, commerce: 65, defense: 50, loyalty: 50 },
        eop: { population: 180000, gold: 10000, food: 1800000, troops: 3000, development: 55, commerce: 50, defense: 50, loyalty: 50 },
    },
};

// ============================================================
// OFFICERS (장수) DATA
// ============================================================

const OFFICERS = [
    // 동탁
    { id: "yeobo", name: "여포", chinese: "吕布", faction: "dongtak", cityId: "nakyang", war: 99, int: 25, pol: 10, cha: 15 },
    { id: "igak", name: "이각", chinese: "李傕", faction: "dongtak", cityId: "jangan", war: 72, int: 40, pol: 20, cha: 15 },
    { id: "gwaksa", name: "곽사", chinese: "郭汜", faction: "dongtak", cityId: "jangan", war: 70, int: 35, pol: 15, cha: 12 },
    { id: "hwaung", name: "화웅", chinese: "华雄", faction: "dongtak", cityId: "nakyang", war: 85, int: 30, pol: 12, cha: 20 },
    // 조조
    { id: "hahudon", name: "하후돈", chinese: "夏侯惇", faction: "jojo", cityId: "jinryu", war: 88, int: 50, pol: 35, cha: 70 },
    { id: "hahuyeon", name: "하후연", chinese: "夏侯渊", faction: "jojo", cityId: "jinryu", war: 86, int: 55, pol: 30, cha: 55 },
    { id: "join", name: "조인", chinese: "曹仁", faction: "jojo", cityId: "jinryu", war: 82, int: 60, pol: 45, cha: 60 },
    { id: "sunuk", name: "순욱", chinese: "荀彧", faction: "jojo", cityId: "jinryu", war: 25, int: 97, pol: 92, cha: 85 },
    // 유비
    { id: "gwanu", name: "관우", chinese: "关羽", faction: "yubi", cityId: "pyeongwon", war: 97, int: 75, pol: 60, cha: 90 },
    { id: "jangbi", name: "장비", chinese: "张飞", faction: "yubi", cityId: "pyeongwon", war: 98, int: 30, pol: 20, cha: 50 },
    { id: "ganong", name: "간옹", chinese: "简雍", faction: "yubi", cityId: "pyeongwon", war: 20, int: 65, pol: 78, cha: 82 },
    // 손견
    { id: "sonchaek", name: "손책", chinese: "孙策", faction: "songyeon", cityId: "jangsa", war: 92, int: 65, pol: 50, cha: 88 },
    { id: "juyu", name: "주유", chinese: "周瑜", faction: "songyeon", cityId: "jangsa", war: 70, int: 96, pol: 80, cha: 90 },
    { id: "hwanggae", name: "황개", chinese: "黄盖", faction: "songyeon", cityId: "jangsa", war: 78, int: 55, pol: 40, cha: 60 },
    { id: "jeongbo", name: "정보", chinese: "程普", faction: "songyeon", cityId: "jangsa", war: 80, int: 60, pol: 50, cha: 65 },
    // 원소
    { id: "allyang", name: "안량", chinese: "颜良", faction: "wonso", cityId: "nampi", war: 93, int: 30, pol: 15, cha: 35 },
    { id: "munchu", name: "문추", chinese: "文丑", faction: "wonso", cityId: "nampi", war: 90, int: 28, pol: 12, cha: 30 },
    { id: "jeonpung", name: "전풍", chinese: "田丰", faction: "wonso", cityId: "nampi", war: 20, int: 92, pol: 88, cha: 70 },
    { id: "simbae", name: "심배", chinese: "审配", faction: "wonso", cityId: "nampi", war: 40, int: 78, pol: 72, cha: 55 },
    // 유표
    { id: "gweryang", name: "괴량", chinese: "蒯良", faction: "yupyo", cityId: "yangyang", war: 25, int: 82, pol: 85, cha: 70 },
    { id: "chaemo", name: "채모", chinese: "蔡瑁", faction: "yupyo", cityId: "yangyang", war: 60, int: 50, pol: 55, cha: 40 },
    { id: "hwangjo", name: "황조", chinese: "黄祖", faction: "yupyo", cityId: "gangha", war: 55, int: 40, pol: 35, cha: 30 },
    // 유장
    { id: "jangim", name: "장임", chinese: "张任", faction: "yujang", cityId: "seongdo", war: 82, int: 55, pol: 40, cha: 45 },
    { id: "eoman", name: "엄안", chinese: "严颜", faction: "yujang", cityId: "gangju", war: 78, int: 50, pol: 45, cha: 55 },
    { id: "beopjeong", name: "법정", chinese: "法正", faction: "yujang", cityId: "seongdo", war: 20, int: 90, pol: 85, cha: 65 },
    // 마등
    { id: "macho", name: "마초", chinese: "马超", faction: "madeung", cityId: "muwi", war: 95, int: 35, pol: 20, cha: 75 },
    { id: "bangdeok", name: "방덕", chinese: "庞德", faction: "madeung", cityId: "cheonsu", war: 88, int: 30, pol: 15, cha: 50 },
    // 공손찬
    { id: "joun", name: "조운", chinese: "赵云", faction: "gongsonchan", cityId: "bukpyeong", war: 96, int: 70, pol: 60, cha: 85 },
    { id: "jeonye", name: "전예", chinese: "田豫", faction: "gongsonchan", cityId: "gye", war: 55, int: 78, pol: 75, cha: 65 },
    // 원술
    { id: "giryeong", name: "기령", chinese: "纪灵", faction: "wonsul", cityId: "suchun", war: 72, int: 30, pol: 20, cha: 25 },
    { id: "yangdaejang", name: "양대장", chinese: "杨大将", faction: "wonsul", cityId: "yeonam", war: 65, int: 25, pol: 15, cha: 20 },
];

// ============================================================
// ADJACENCY GRAPH (bidirectional)
// ============================================================

const ADJACENCY = {
    // 유주
    bukpyeong: ["gye", "nampi"],
    gye: ["bukpyeong", "nampi", "jinyang"],
    // 병주
    jinyang: ["gye", "sangdang", "eop"],
    sangdang: ["jinyang", "eop", "nakyang"],
    // 기주
    eop: ["jinyang", "nampi", "pyeongwon", "bokyang", "sangdang"],
    nampi: ["bukpyeong", "gye", "eop", "pyeongwon"],
    pyeongwon: ["nampi", "eop", "bokyang", "imchi"],
    // 청주
    imchi: ["pyeongwon", "bokyang", "sopae", "bukhae", "taesan", "nangya"],
    bukhae: ["imchi", "nangya"],
    // 연주
    jinryu: ["bokyang", "nakyang", "heochang", "sopae", "cho"],
    bokyang: ["eop", "pyeongwon", "jinryu", "sopae", "imchi", "sanyang"],
    sanyang: ["bokyang", "sopae", "cho", "taesan"],
    taesan: ["sanyang", "imchi", "nangya"],
    // 서주
    paengseong: ["sopae", "habi"],
    habi: ["paengseong", "sopae", "gwangneung", "suchun", "nangya", "donghae"],
    sopae: ["bokyang", "jinryu", "imchi", "paengseong", "habi", "sanyang", "cho"],
    gwangneung: ["habi", "suchun", "geonup", "donghae"],
    nangya: ["taesan", "imchi", "bukhae", "donghae", "habi"],
    donghae: ["nangya", "habi", "gwangneung"],
    // 예주
    heochang: ["jinryu", "nakyang", "yeonam", "wan", "cho"],
    yeonam: ["heochang", "wan", "suchun", "namyang", "yeoeum"],
    suchun: ["yeonam", "habi", "gwangneung", "yeogang", "yeoeum"],
    cho: ["jinryu", "sopae", "sanyang", "yeonam", "yeoeum", "heochang"],
    yeoeum: ["cho", "yeonam", "suchun"],
    wan: ["heochang", "yeonam", "namyang", "nakyang"],
    namyang: ["wan", "yeonam", "yangyang", "sinya", "sangyong"],
    // 사예
    nakyang: ["sangdang", "jinryu", "heochang", "wan", "jangan"],
    jangan: ["nakyang", "anjeong", "cheonsu", "hanjung"],
    // 양주(량)
    cheonsu: ["jangan", "anjeong", "hanjung"],
    muwi: ["anjeong"],
    anjeong: ["jangan", "cheonsu", "muwi"],
    // 형주
    yangyang: ["namyang", "sinya", "gangneung", "gangha", "sangyong"],
    gangneung: ["yangyang", "gangha", "mureung", "jangsa", "yeongan"],
    gangha: ["yangyang", "gangneung", "jangsa", "sisang", "yeogang"],
    jangsa: ["gangneung", "gangha", "gyeyang", "yeongneung", "mureung"],
    gyeyang: ["jangsa", "yeongneung", "beonu"],
    yeongneung: ["jangsa", "gyeyang", "mureung"],
    mureung: ["gangneung", "jangsa", "yeongneung"],
    sinya: ["namyang", "yangyang", "sangyong"],
    sangyong: ["namyang", "sinya", "yangyang", "hanjung", "yeongan"],
    // 익주
    seongdo: ["jaedong", "gangju", "geonnyeong"],
    hanjung: ["jangan", "cheonsu", "sangyong", "jaedong", "nangjung"],
    jaedong: ["hanjung", "seongdo", "nangjung"],
    nangjung: ["hanjung", "jaedong", "gangju", "yeongan"],
    gangju: ["seongdo", "nangjung", "yeongan", "geonnyeong"],
    yeongan: ["nangjung", "gangju", "gangneung", "sangyong"],
    geonnyeong: ["seongdo", "gangju", "yeongchang", "unnam"],
    yeongchang: ["geonnyeong", "unnam"],
    unnam: ["geonnyeong", "yeongchang"],
    // 양주(양)
    geonup: ["gwangneung", "yeogang", "ogun"],
    ogun: ["geonup", "hoegye"],
    hoegye: ["ogun", "yejang"],
    sisang: ["gangha", "yeogang", "yejang"],
    yeogang: ["suchun", "geonup", "sisang", "yejang"],
    yejang: ["sisang", "yeogang", "hoegye", "beonu"],
    // 교주
    beonu: ["gyeyang", "yejang", "gyoji"],
    gyoji: ["beonu"],
};

// ============================================================
// GAME STATE
// ============================================================

let gameState = null;
let selectedFaction = null;
let selectedCityId = null;
let map = null;
let cityMarkers = {};
let cityLabels = {};
let troopBadges = {};
let attackLines = [];    // Leaflet polylines for attack mode
let attackMode = false;  // true when selecting attack target
let turnProcessing = false; // guard against double endTurn calls

// ============================================================
// TITLE SCREEN
// ============================================================

function initTitleScreen() {
    const grid = document.getElementById('faction-grid');
    grid.innerHTML = '';
    for (const [fid, f] of Object.entries(FACTIONS)) {
        const cityCount = Object.values(SCENARIO_190.cityOwners).filter(o => o === fid).length;
        const card = document.createElement('div');
        card.className = 'faction-card';
        card.dataset.faction = fid;
        card.innerHTML = `
            <div class="lord" style="color:${f.color}">${f.name}</div>
            <div style="font-size:12px; color:#888">${f.chinese}</div>
            <div class="cities">${f.desc}<br>도시 ${cityCount}개</div>
            <div class="color-bar" style="background:${f.color}"></div>
        `;
        card.onclick = () => selectFaction(fid);
        grid.appendChild(card);
    }
}

function selectFaction(fid) {
    selectedFaction = fid;
    document.querySelectorAll('.faction-card').forEach(c => c.classList.remove('selected'));
    document.querySelector(`.faction-card[data-faction="${fid}"]`).classList.add('selected');
    document.getElementById('start-btn').disabled = false;
}

// ============================================================
// GAME INITIALIZATION
// ============================================================

function startGame() {
    if (!selectedFaction) return;
    document.getElementById('title-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';

    initGameState();
    initMap();
    updateAllUI();
    addLog('시스템', `${FACTIONS[selectedFaction].name}(으)로 게임을 시작합니다.`, 'info');
}

function initGameState() {
    const sc = SCENARIO_190;
    const cities = {};

    for (const city of GAME_CITIES) {
        const owner = sc.cityOwners[city.id] || null;
        const override = sc.cityStats[city.id] || {};
        cities[city.id] = {
            id: city.id,
            korean: city.korean,
            name: city.name,
            region: city.region,
            lat: city.lat,
            lng: city.lng,
            owner: owner,
            population: override.population || (owner ? 80000 + Math.floor(Math.random() * 60000) : 50000 + Math.floor(Math.random() * 30000)),
            gold: override.gold || (owner ? 8000 + Math.floor(Math.random() * 6000) : 3000),
            food: override.food || (owner ? 1500000 + Math.floor(Math.random() * 1000000) : 500000),
            troops: override.troops || (owner ? 5000 + Math.floor(Math.random() * 5000) : 1000 + Math.floor(Math.random() * 2000)),
            development: override.development || (owner ? 35 + Math.floor(Math.random() * 25) : 20 + Math.floor(Math.random() * 20)),
            commerce: override.commerce || (owner ? 30 + Math.floor(Math.random() * 25) : 15 + Math.floor(Math.random() * 20)),
            defense: override.defense || (owner ? 20 + Math.floor(Math.random() * 30) : 10 + Math.floor(Math.random() * 15)),
            loyalty: override.loyalty || (owner ? 50 + Math.floor(Math.random() * 30) : 40),
            actionsLeft: 3,
        };
    }

    // Faction resources (aggregate from cities)
    const factions = {};
    for (const [fid, f] of Object.entries(FACTIONS)) {
        factions[fid] = { gold: 0, food: 0, totalTroops: 0, cityCount: 0 };
    }
    for (const c of Object.values(cities)) {
        if (c.owner && factions[c.owner]) {
            factions[c.owner].gold += c.gold;
            factions[c.owner].food += c.food;
            factions[c.owner].totalTroops += c.troops;
            factions[c.owner].cityCount++;
        }
    }

    // Initialize officers
    const officers = OFFICERS.map(o => ({ ...o }));

    gameState = {
        year: sc.year,
        month: sc.month,
        turn: 1,
        playerFaction: selectedFaction,
        cities: cities,
        factions: factions,
        eliminated: [],
        officers: officers,
    };
}

// ============================================================
// MAP
// ============================================================

function initMap() {
    map = L.map('map', { center: [33, 110], zoom: 5, minZoom: 4, maxZoom: 12 });
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '&copy; ESRI', maxZoom: 18
    }).addTo(map);

    for (const city of GAME_CITIES) {
        createCityMarker(city.id);
    }
}

function getCityColor(cityId) {
    const city = gameState.cities[cityId];
    if (!city.owner) return '#666';
    return FACTIONS[city.owner]?.color || '#666';
}

function createCityMarker(cityId) {
    const city = gameState.cities[cityId];
    const color = getCityColor(cityId);
    const size = city.owner ? 18 : 14;

    const icon = L.divIcon({
        className: '',
        html: `<div class="city-marker" id="marker-${cityId}" style="width:${size}px;height:${size}px;background:${color};"></div>`,
        iconSize: [size, size],
        iconAnchor: [size/2, size/2],
    });

    const marker = L.marker([city.lat, city.lng], { icon: icon }).addTo(map);
    marker.on('click', () => selectCity(cityId));
    cityMarkers[cityId] = marker;

    // City name label
    const label = L.marker([city.lat, city.lng], {
        icon: L.divIcon({
            className: 'city-label-game',
            html: city.korean,
            iconSize: [60, 16],
            iconAnchor: [30, -8],
        }),
        interactive: false,
    }).addTo(map);
    cityLabels[cityId] = label;

    // Troop badge
    const badge = L.marker([city.lat, city.lng], {
        icon: L.divIcon({
            className: 'troop-badge',
            html: formatTroops(city.troops),
            iconSize: [50, 14],
            iconAnchor: [25, -20],
        }),
        interactive: false,
    }).addTo(map);
    troopBadges[cityId] = badge;
}

function updateCityMarker(cityId) {
    const city = gameState.cities[cityId];
    const color = getCityColor(cityId);
    const size = city.owner ? 18 : 14;
    const isSelected = (cityId === selectedCityId);

    const el = document.getElementById(`marker-${cityId}`);
    if (el) {
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        el.style.background = color;
        if (isSelected) {
            el.classList.add('selected');
        } else {
            el.classList.remove('selected');
        }
    }

    // Update troop badge
    if (troopBadges[cityId]) {
        troopBadges[cityId].setIcon(L.divIcon({
            className: 'troop-badge',
            html: formatTroops(city.troops),
            iconSize: [50, 14],
            iconAnchor: [25, -20],
        }));
    }
}

// ============================================================
// CITY SELECTION & PANEL
// ============================================================

function selectCity(cityId) {
    if (attackMode) {
        cancelAttackMode();
    }
    const prevId = selectedCityId;
    selectedCityId = cityId;
    if (prevId) updateCityMarker(prevId);
    updateCityMarker(cityId);
    updateCityPanel();
}

function updateCityPanel() {
    const noCityMsg = document.getElementById('no-city-msg');
    const cityInfo = document.getElementById('city-info');

    if (!selectedCityId) {
        noCityMsg.style.display = 'block';
        cityInfo.style.display = 'none';
        return;
    }

    noCityMsg.style.display = 'none';
    cityInfo.style.display = 'block';

    const city = gameState.cities[selectedCityId];
    const ownerName = city.owner ? FACTIONS[city.owner].name : '공백지';
    const ownerColor = city.owner ? FACTIONS[city.owner].color : '#666';
    const isPlayerCity = city.owner === gameState.playerFaction;

    const goldIncome = calcGoldIncome(city);
    const foodIncome = calcFoodIncome(city);
    const troopCostGold = Math.floor(city.troops * 0.05);
    const troopCostFood = Math.floor(city.troops * 8);

    cityInfo.innerHTML = `
        <h3>${city.korean} (${city.name})</h3>
        <div class="city-owner" style="color:${ownerColor}">${ownerName} | ${city.region}</div>

        <div class="city-stats">
            ${statRow('인구', formatNum(city.population), '')}
            ${statRow('금', formatNum(city.gold), `+${formatNum(goldIncome)}/턴`, '#ffd700')}
            ${statRow('식량', formatNum(city.food), `+${formatNum(foodIncome)}/턴`, '#8bc34a')}
            ${statRow('병력', formatNum(city.troops), `-금${formatNum(troopCostGold)} -식${formatNum(troopCostFood)}`, '#f44336')}
            ${barRow('개발', city.development, '#4caf50')}
            ${barRow('상업', city.commerce, '#ff9800')}
            ${barRow('방어', city.defense, '#2196f3')}
            ${barRow('충성', city.loyalty, '#e91e63')}
        </div>

        ${officersHTML(city, isPlayerCity)}
        ${isPlayerCity ? actionsHTML(city) : '<div style="color:#888;text-align:center;margin-top:20px;font-size:12px;">자신의 도시만 관리할 수 있습니다</div>'}
    `;
}

function statRow(label, value, sub, color) {
    return `<div class="city-stat-row">
        <span class="label">${label}</span>
        <span>
            <span class="value" ${color ? `style="color:${color}"` : ''}>${value}</span>
            ${sub ? `<span style="font-size:10px;color:#888;margin-left:4px;">${sub}</span>` : ''}
        </span>
    </div>`;
}

function barRow(label, value, color) {
    return `<div class="city-stat-row">
        <span class="label">${label}</span>
        <span style="display:flex;align-items:center;gap:8px;">
            <span class="value" style="width:28px;text-align:right;">${value}</span>
            <div class="stat-bar-bg"><div class="stat-bar" style="width:${value}%;background:${color};"></div></div>
        </span>
    </div>`;
}

function officersHTML(city, isPlayerCity) {
    const officers = getOfficersAt(city.id);
    if (officers.length === 0) {
        return `<div class="officer-section"><h4 class="officer-header">장수</h4><div class="no-officer">배치된 장수 없음</div></div>`;
    }

    // For player cities, get adjacent own cities for movement
    let adjOwnCities = [];
    if (isPlayerCity) {
        adjOwnCities = (ADJACENCY[city.id] || [])
            .map(id => gameState.cities[id])
            .filter(c => c && c.owner === gameState.playerFaction);
    }

    let html = `<div class="officer-section"><h4 class="officer-header">장수 (${officers.length}명)</h4>`;
    for (const o of officers) {
        html += `<div class="officer-card">
            <div class="officer-name">${o.name} <span class="officer-chinese">${o.chinese}</span></div>
            <div class="officer-stats">
                <span class="os-war" title="무력">무 ${o.war}</span>
                <span class="os-int" title="지력">지 ${o.int}</span>
                <span class="os-pol" title="정치">정 ${o.pol}</span>
                <span class="os-cha" title="매력">매 ${o.cha}</span>
            </div>`;
        if (isPlayerCity && adjOwnCities.length > 0) {
            html += `<div class="officer-move">`;
            for (const ac of adjOwnCities) {
                html += `<button class="officer-move-btn" onclick="moveOfficer('${o.id}','${ac.id}')" title="${ac.korean}(으)로 이동">${ac.korean}</button>`;
            }
            html += `</div>`;
        }
        html += `</div>`;
    }
    html += `</div>`;
    return html;
}

function moveOfficer(officerId, targetCityId) {
    if (!gameState || !gameState.officers) return;
    const officer = gameState.officers.find(o => o.id === officerId);
    if (!officer) return;

    const srcCity = gameState.cities[officer.cityId];
    const dstCity = gameState.cities[targetCityId];
    if (!srcCity || !dstCity) return;
    if (srcCity.owner !== gameState.playerFaction || dstCity.owner !== gameState.playerFaction) return;

    // Check adjacency
    if (!(ADJACENCY[srcCity.id] || []).includes(targetCityId)) return;

    // Check if source city has actions left
    if (srcCity.actionsLeft <= 0) {
        addLog(srcCity.korean, `행동력이 부족하여 장수를 이동할 수 없습니다.`, 'bad');
        return;
    }

    srcCity.actionsLeft--;
    officer.cityId = targetCityId;
    addLog(srcCity.korean, `${officer.name}(을)를 ${dstCity.korean}(으)로 이동`, 'info');
    updateCityPanel();
    updateTopBar();
}

function actionsHTML(city) {
    if (city.actionsLeft <= 0) {
        return `<div class="action-section">
            <h4>행동</h4>
            <div style="color:#f44336;text-align:center;font-size:12px;padding:10px;">이번 턴 행동 완료 (0/3)</div>
        </div>`;
    }

    // Attack mode: show target list
    if (attackMode && selectedCityId === city.id) {
        return attackTargetHTML(city);
    }

    const canDev = city.gold >= 300 && city.development < 100;
    const canCom = city.gold >= 300 && city.commerce < 100;
    const canDef = city.gold >= 500 && city.defense < 100;
    const canRecruit = city.gold >= 200 && city.food >= 30000 && city.population >= 3000;

    const targets = getAttackTargets(city.id);
    const canAttack = city.troops >= 1000 && targets.length > 0;

    return `<div class="action-section">
        <h4>행동 (남은 횟수: ${city.actionsLeft}/3)</h4>
        <button class="action-btn" ${canDev ? '' : 'disabled'} onclick="doAction('${city.id}','develop')">
            <span>개발 (개발+5)</span><span class="cost">금 300</span>
        </button>
        <button class="action-btn" ${canCom ? '' : 'disabled'} onclick="doAction('${city.id}','commerce')">
            <span>상업 (상업+5)</span><span class="cost">금 300</span>
        </button>
        <button class="action-btn" ${canDef ? '' : 'disabled'} onclick="doAction('${city.id}','defense')">
            <span>방비 (방어+5)</span><span class="cost">금 500</span>
        </button>
        <button class="action-btn" ${canRecruit ? '' : 'disabled'} onclick="doAction('${city.id}','recruit')">
            <span>징병 (병력+1000)</span><span class="cost">금200 식30,000</span>
        </button>
        <button class="action-btn attack-btn" ${canAttack ? '' : 'disabled'} onclick="enterAttackMode('${city.id}')">
            <span>⚔ 출병</span><span class="cost">행동 1 소모</span>
        </button>
    </div>`;
}

function attackTargetHTML(city) {
    const targets = getAttackTargets(city.id);
    let html = `<div class="attack-target-panel">
        <h4>⚔ 출병 대상 선택 (${city.korean})</h4>`;

    for (const t of targets) {
        const ownerName = t.owner ? FACTIONS[t.owner].name : '공백지';
        const ownerColor = t.owner ? FACTIONS[t.owner].color : '#888';
        const isEmpty = !t.owner || t.troops <= 0;
        html += `<button class="target-btn ${isEmpty ? 'empty-city' : ''}" onclick="selectAttackTarget('${city.id}','${t.id}')">
            <span>${t.korean} <span style="color:${ownerColor}">(${ownerName})</span></span>
            <span class="target-info">병력 ${formatNum(t.troops)}</span>
        </button>`;
    }

    html += `<button class="cancel-attack-btn" onclick="cancelAttackMode()">취소</button>`;
    html += `</div>`;
    return html;
}

// ============================================================
// CITY ACTIONS
// ============================================================

function doAction(cityId, action) {
    const city = gameState.cities[cityId];
    if (!city || city.owner !== gameState.playerFaction || city.actionsLeft <= 0) return;

    const polBonus = devBonus(cityId);
    const chaBonus = recruitBonus(cityId);

    switch(action) {
        case 'develop':
            if (city.gold < 300 || city.development >= 100) return;
            city.gold -= 300;
            const devInc = 5 + polBonus;
            city.development = Math.min(100, city.development + devInc);
            city.actionsLeft--;
            addLog(city.korean, `개발 실시 (개발 +${devInc}${polBonus > 0 ? ' 장수보너스+' + polBonus : ''} → ${city.development})`, 'good');
            break;
        case 'commerce':
            if (city.gold < 300 || city.commerce >= 100) return;
            city.gold -= 300;
            const comInc = 5 + polBonus;
            city.commerce = Math.min(100, city.commerce + comInc);
            city.actionsLeft--;
            addLog(city.korean, `상업 투자 (상업 +${comInc}${polBonus > 0 ? ' 장수보너스+' + polBonus : ''} → ${city.commerce})`, 'good');
            break;
        case 'defense':
            if (city.gold < 500 || city.defense >= 100) return;
            city.gold -= 500;
            city.defense = Math.min(100, city.defense + 5);
            city.actionsLeft--;
            addLog(city.korean, `방비 강화 (방어 → ${city.defense})`, 'good');
            break;
        case 'recruit':
            if (city.gold < 200 || city.food < 30000 || city.population < 3000) return;
            city.gold -= 200;
            city.food -= 30000;
            const totalRecruit = 1000 + chaBonus;
            city.troops += totalRecruit;
            city.population -= 1000;
            city.actionsLeft--;
            addLog(city.korean, `징병 실시 (병력 +${formatNum(totalRecruit)}${chaBonus > 0 ? ' 장수보너스+' + chaBonus : ''}, 현재 ${formatNum(city.troops)})`, 'good');
            break;
    }

    updateCityPanel();
    updateCityMarker(cityId);
    updateTopBar();
    updateFactionPanel();
}

// ============================================================
// ECONOMY ENGINE
// ============================================================

function getSeason(month) {
    if (month >= 3 && month <= 5) return { name: '봄', class: 'season-spring', foodMod: 1.0 };
    if (month >= 6 && month <= 8) return { name: '여름', class: 'season-summer', foodMod: 1.2 };
    if (month >= 9 && month <= 11) return { name: '가을', class: 'season-autumn', foodMod: 1.5 };
    return { name: '겨울', class: 'season-winter', foodMod: 0.5 };
}

function calcGoldIncome(city) {
    return Math.floor(city.population / 1000 * city.commerce / 100 * 5);
}

function calcFoodIncome(city) {
    const season = getSeason(gameState.month);
    return Math.floor(city.population / 1000 * city.development / 100 * 800 * season.foodMod);
}

function processTurnEconomy() {
    const season = getSeason(gameState.month);

    for (const city of Object.values(gameState.cities)) {
        if (!city.owner) continue;

        // Income
        const goldIncome = calcGoldIncome(city);
        const foodIncome = calcFoodIncome(city);
        city.gold += goldIncome;
        city.food += foodIncome;

        // Troop maintenance
        const troopCostGold = Math.floor(city.troops * 0.05);
        const troopCostFood = Math.floor(city.troops * 8);
        city.gold -= troopCostGold;
        city.food -= troopCostFood;

        // Gold minimum 0
        if (city.gold < 0) city.gold = 0;

        // Food shortage → desertion
        if (city.food < 0) {
            const deserted = Math.min(city.troops, Math.floor(Math.abs(city.food) / 50));
            const actualDesert = Math.max(100, Math.floor(deserted * 0.3));
            city.troops = Math.max(0, city.troops - actualDesert);
            city.food = 0;
            city.loyalty = Math.max(0, city.loyalty - 5);
            if (city.owner === gameState.playerFaction) {
                addLog(city.korean, `식량 부족! 병사 ${formatNum(actualDesert)}명 탈영, 충성도 하락`, 'bad');
            }
        }

        // Population growth (small)
        if (city.food > 0 && city.loyalty > 30) {
            city.population += Math.floor(city.population * 0.002);
        }

        // Loyalty drift toward 50 if no action
        if (city.loyalty < 50) city.loyalty = Math.min(50, city.loyalty + 1);
        if (city.loyalty > 80) city.loyalty = Math.max(80, city.loyalty - 1);

        // Reset actions
        city.actionsLeft = 3;
    }
}

// ============================================================
// AI
// ============================================================

function processAITurns() {
    for (const [fid, faction] of Object.entries(FACTIONS)) {
        if (fid === gameState.playerFaction) continue;
        if (gameState.eliminated.includes(fid)) continue;

        const myCities = Object.values(gameState.cities).filter(c => c.owner === fid);
        if (myCities.length === 0) {
            if (!gameState.eliminated.includes(fid)) {
                gameState.eliminated.push(fid);
                addLog('시스템', `${faction.name} 세력이 멸망했습니다!`, 'bad');
            }
            continue;
        }

        for (const city of myCities) {
            // AI gets 3 actions per city per turn
            while (city.actionsLeft > 0) {
                let didAction = false;

                if (city.troops < 3000 && city.gold >= 200 && city.food >= 30000 && city.population >= 3000) {
                    city.gold -= 200; city.food -= 30000;
                    city.troops += 1000; city.population -= 1000;
                    city.actionsLeft--; didAction = true;
                } else if (city.development < 60 && city.gold >= 300) {
                    city.gold -= 300;
                    city.development = Math.min(100, city.development + 5);
                    city.actionsLeft--; didAction = true;
                } else if (city.commerce < 60 && city.gold >= 300) {
                    city.gold -= 300;
                    city.commerce = Math.min(100, city.commerce + 5);
                    city.actionsLeft--; didAction = true;
                } else if (city.defense < 40 && city.gold >= 500) {
                    city.gold -= 500;
                    city.defense = Math.min(100, city.defense + 5);
                    city.actionsLeft--; didAction = true;
                } else if (city.gold >= 300) {
                    if (Math.random() < 0.5 && city.development < 100) {
                        city.gold -= 300;
                        city.development = Math.min(100, city.development + 5);
                        city.actionsLeft--; didAction = true;
                    } else if (city.commerce < 100) {
                        city.gold -= 300;
                        city.commerce = Math.min(100, city.commerce + 5);
                        city.actionsLeft--; didAction = true;
                    } else {
                        break;
                    }
                } else {
                    break; // not enough gold
                }

                if (!didAction) break;
            }
        }
    }
}

// AI Officer Management
function processAIOfficerMoves() {
    if (!gameState || !gameState.officers) return;
    for (const [fid, faction] of Object.entries(FACTIONS)) {
        if (fid === gameState.playerFaction) continue;
        if (gameState.eliminated.includes(fid)) continue;

        const myCities = Object.values(gameState.cities).filter(c => c.owner === fid);
        if (myCities.length <= 1) continue;

        // Find frontline cities (adjacent to enemy)
        const frontline = myCities.filter(c => {
            const adj = ADJACENCY[c.id] || [];
            return adj.some(id => {
                const ac = gameState.cities[id];
                return ac && ac.owner && ac.owner !== fid;
            });
        });
        if (frontline.length === 0) continue;

        // Move high-war officers to frontline
        const myOfficers = getOfficersOfFaction(fid);
        for (const off of myOfficers) {
            if (off.war < 70) continue; // only move strong warriors
            const currentCity = gameState.cities[off.cityId];
            if (!currentCity || currentCity.owner !== fid) continue;
            // Already on frontline?
            if (frontline.some(f => f.id === off.cityId)) continue;
            // Try to move to adjacent frontline city
            const adjIds = ADJACENCY[off.cityId] || [];
            const adjFrontline = frontline.filter(f => adjIds.includes(f.id));
            if (adjFrontline.length > 0) {
                off.cityId = adjFrontline[0].id;
            }
        }
    }
}

// ============================================================
// TURN SYSTEM
// ============================================================

function endTurn() {
    // Prevent double-processing from rapid clicks
    if (turnProcessing) return;
    turnProcessing = true;

    // Cancel attack mode if active
    if (attackMode) cancelAttackMode();

    // Show transition
    const turnOverlay = document.getElementById('turn-overlay');
    const turnMsg = document.getElementById('turn-msg');
    turnOverlay.classList.add('active');
    turnMsg.textContent = '턴 처리 중...';

    setTimeout(() => {
        // 1. AI internal actions (develop, recruit, etc.)
        processAITurns();

        // 1.5 AI officer management
        processAIOfficerMoves();

        // 2. AI combat
        processAICombat();

        // 3. Economy
        processTurnEconomy();

        // 4. Advance month
        gameState.month++;
        if (gameState.month > 12) {
            gameState.month = 1;
            gameState.year++;
        }
        gameState.turn++;

        // 5. Recalculate faction aggregates
        recalcFactions();

        // 6. Season log
        const season = getSeason(gameState.month);
        if (gameState.month === 1) {
            addLog('시스템', `${gameState.year}년이 시작되었습니다.`, 'info');
        }

        // Update UI
        updateAllUI();

        turnMsg.textContent = `${gameState.year}년 ${gameState.month}월 (${season.name})`;
        setTimeout(() => {
            turnOverlay.classList.remove('active');
            turnProcessing = false;
            // 7. Check victory/defeat after UI update
            checkVictory();
            checkGameOver();
        }, 800);
    }, 300);
}

function recalcFactions() {
    for (const fid of Object.keys(FACTIONS)) {
        gameState.factions[fid] = { gold: 0, food: 0, totalTroops: 0, cityCount: 0 };
    }
    for (const c of Object.values(gameState.cities)) {
        if (c.owner && gameState.factions[c.owner]) {
            gameState.factions[c.owner].gold += c.gold;
            gameState.factions[c.owner].food += c.food;
            gameState.factions[c.owner].totalTroops += c.troops;
            gameState.factions[c.owner].cityCount++;
        }
    }
}

// ============================================================
// UI UPDATES
// ============================================================

function updateAllUI() {
    updateTopBar();
    updateFactionPanel();
    updateCityPanel();
    for (const cityId of Object.keys(gameState.cities)) {
        updateCityMarker(cityId);
    }
}

function updateTopBar() {
    const season = getSeason(gameState.month);
    document.getElementById('turn-date').textContent = `${gameState.year}년 ${gameState.month}월`;
    const seasonEl = document.getElementById('turn-season');
    seasonEl.textContent = season.name;
    seasonEl.className = `season ${season.class}`;

    // Player totals
    recalcFactions();
    const pf = gameState.factions[gameState.playerFaction];
    document.getElementById('res-gold').textContent = formatNum(pf.gold);
    document.getElementById('res-food').textContent = formatNum(pf.food);
    document.getElementById('res-troops').textContent = formatNum(pf.totalTroops);
    document.getElementById('res-cities').textContent = pf.cityCount;
}

function updateFactionPanel() {
    recalcFactions();
    const listEl = document.getElementById('faction-list');
    const detailEl = document.getElementById('faction-detail');

    // Sort factions by city count desc
    const sorted = Object.entries(FACTIONS).sort((a, b) => {
        return (gameState.factions[b[0]]?.cityCount || 0) - (gameState.factions[a[0]]?.cityCount || 0);
    });

    let html = '';
    for (const [fid, f] of sorted) {
        const fd = gameState.factions[fid];
        const isCurrent = fid === gameState.playerFaction;
        const isEliminated = gameState.eliminated.includes(fid);
        html += `<div class="faction-row ${isCurrent ? 'current' : ''}" style="${isEliminated ? 'opacity:0.3;' : ''}">
            <span class="f-color" style="background:${f.color}"></span>
            <span class="f-name">${f.name}${isCurrent ? ' (나)' : ''}</span>
            <span class="f-stat">${fd.cityCount}城 ${formatTroops(fd.totalTroops)}</span>
        </div>`;
    }
    listEl.innerHTML = html;

    // Detail for player
    const pf = gameState.factions[gameState.playerFaction];
    const playerCities = Object.values(gameState.cities).filter(c => c.owner === gameState.playerFaction);
    const totalGoldIncome = playerCities.reduce((s, c) => s + calcGoldIncome(c), 0);
    const totalFoodIncome = playerCities.reduce((s, c) => s + calcFoodIncome(c), 0);
    const totalTroopCostGold = playerCities.reduce((s, c) => s + Math.floor(c.troops * 0.05), 0);
    const totalTroopCostFood = playerCities.reduce((s, c) => s + Math.floor(c.troops * 8), 0);

    detailEl.innerHTML = `
        <h4>${FACTIONS[gameState.playerFaction].name} 세력</h4>
        <div class="stat-row"><span class="stat-label">도시</span><span class="stat-val">${pf.cityCount}개</span></div>
        <div class="stat-row"><span class="stat-label">총 금</span><span class="stat-val" style="color:#ffd700">${formatNum(pf.gold)}</span></div>
        <div class="stat-row"><span class="stat-label">금 수입</span><span class="stat-val" style="color:#ffd700">+${formatNum(totalGoldIncome)}/턴</span></div>
        <div class="stat-row"><span class="stat-label">금 지출</span><span class="stat-val" style="color:#f44336">-${formatNum(totalTroopCostGold)}/턴</span></div>
        <div class="stat-row"><span class="stat-label">총 식량</span><span class="stat-val" style="color:#8bc34a">${formatNum(pf.food)}</span></div>
        <div class="stat-row"><span class="stat-label">식량 수입</span><span class="stat-val" style="color:#8bc34a">+${formatNum(totalFoodIncome)}/턴</span></div>
        <div class="stat-row"><span class="stat-label">식량 지출</span><span class="stat-val" style="color:#f44336">-${formatNum(totalTroopCostFood)}/턴</span></div>
        <div class="stat-row"><span class="stat-label">총 병력</span><span class="stat-val" style="color:#ef5350">${formatNum(pf.totalTroops)}</span></div>
    `;
}

// ============================================================
// EVENT LOG
// ============================================================

function addLog(source, text, type) {
    const logEl = document.getElementById('event-log');
    const cls = type === 'good' ? 'log-good' : type === 'bad' ? 'log-bad' : type === 'info' ? 'log-info' : 'log-text';
    const turnLabel = gameState ? `${gameState.year}년 ${gameState.month}월` : source;
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-turn">[${turnLabel}]</span> <span class="${cls}">${source !== '시스템' ? `[${source}] ` : ''}${text}</span>`;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
}

// ============================================================
// MENU
// ============================================================

function toggleMenu() {
    document.getElementById('menu-overlay').classList.toggle('active');
}

// ============================================================
// UTILITIES
// ============================================================

function formatNum(n) {
    if (n === undefined || n === null) return '0';
    return n.toLocaleString();
}

function formatTroops(n) {
    if (n >= 10000) return (n / 10000).toFixed(1) + '만';
    if (n >= 1000) return (n / 1000).toFixed(1) + '천';
    return String(n);
}

// ============================================================
// OFFICER SYSTEM
// ============================================================

function getOfficersAt(cityId) {
    if (!gameState || !gameState.officers) return [];
    return gameState.officers.filter(o => o.cityId === cityId);
}

function getOfficersOfFaction(factionId) {
    if (!gameState || !gameState.officers) return [];
    return gameState.officers.filter(o => o.faction === factionId);
}

function getTopOfficer(cityId, stat) {
    const officers = getOfficersAt(cityId);
    if (officers.length === 0) return null;
    return officers.reduce((best, o) => (o[stat] > best[stat]) ? o : best, officers[0]);
}

function combatBonus(cityId) {
    const top = getTopOfficer(cityId, 'war');
    if (!top) return 0;
    return top.war / 100 * 0.5; // 0 ~ 0.5 multiplier bonus
}

function devBonus(cityId) {
    const top = getTopOfficer(cityId, 'pol');
    if (!top) return 0;
    return Math.floor(top.pol / 35); // +1 ~ +2 (pol 35~70 → +1, 70~100 → +2)
}

function recruitBonus(cityId) {
    const top = getTopOfficer(cityId, 'cha');
    if (!top) return 0;
    return Math.floor(top.cha / 100 * 500); // up to +500
}

function defenseBonus(cityId) {
    const top = getTopOfficer(cityId, 'int');
    if (!top) return 0;
    return Math.floor(top.int / 10); // +0 ~ +10 defense bonus
}

// ============================================================
// COMBAT ENGINE
// ============================================================

function getAdjacentCities(cityId) {
    return (ADJACENCY[cityId] || []).map(id => gameState.cities[id]).filter(Boolean);
}

function resolveBattle(attackTroops, defCity, srcCityId, dstCityId) {
    // Empty city → bloodless capture
    if (!defCity.owner || defCity.troops <= 0) {
        return { victory: true, attLoss: 0, defLoss: 0, attRemain: attackTroops, defRemain: 0 };
    }

    const rand = () => 0.8 + Math.random() * 0.4; // 0.8 ~ 1.2
    const attOfficerBonus = srcCityId ? combatBonus(srcCityId) : 0;
    const defOfficerBonus = dstCityId ? combatBonus(dstCityId) : 0;
    const defIntBonus = dstCityId ? defenseBonus(dstCityId) : 0;
    const attackPower = attackTroops * (1 + attOfficerBonus) * rand();
    const defensePower = defCity.troops * ((defCity.defense + defIntBonus) / 100) * (1 + defOfficerBonus) * rand();

    const victory = attackPower > defensePower;

    if (victory) {
        const defLossRate = 0.4 + Math.random() * 0.2; // 40~60%
        const attLossRate = 0.2 + Math.random() * 0.1; // 20~30%
        const defLoss = Math.floor(defCity.troops * defLossRate);
        const attLoss = Math.floor(attackTroops * attLossRate);
        return {
            victory: true,
            attLoss, defLoss,
            attRemain: Math.max(1, attackTroops - attLoss),
            defRemain: Math.max(0, defCity.troops - defLoss),
        };
    } else {
        // Attacker annihilated
        const defLossRate = 0.2 + Math.random() * 0.1;
        const defLoss = Math.floor(defCity.troops * defLossRate);
        return {
            victory: false,
            attLoss: attackTroops, defLoss,
            attRemain: 0,
            defRemain: Math.max(1, defCity.troops - defLoss),
        };
    }
}

function applyBattleResult(srcCity, dstCity, attackTroops, result, attackerFaction, srcCityId) {
    // Deduct attacking troops from source
    srcCity.troops -= attackTroops;
    if (srcCity.troops < 0) srcCity.troops = 0;

    if (result.victory) {
        const oldOwner = dstCity.owner;
        dstCity.owner = attackerFaction;
        dstCity.troops = result.attRemain;
        dstCity.loyalty = Math.max(20, dstCity.loyalty - 20);
        // Move one officer from source to conquered city (highest war)
        if (srcCityId) {
            const srcOfficers = getOfficersAt(srcCityId).filter(o => o.faction === attackerFaction);
            if (srcOfficers.length > 1) {
                const topWar = srcOfficers.reduce((a, b) => a.war > b.war ? a : b);
                topWar.cityId = dstCity.id;
            }
        }
        // Check if old owner eliminated
        if (oldOwner) checkElimination(oldOwner, attackerFaction);
    } else {
        dstCity.troops = result.defRemain;
    }
}

function checkElimination(factionId, conquerorId) {
    if (gameState.eliminated.includes(factionId)) return;
    const hasCities = Object.values(gameState.cities).some(c => c.owner === factionId);
    if (!hasCities) {
        gameState.eliminated.push(factionId);
        addLog('시스템', `${FACTIONS[factionId].name} 세력이 멸망했습니다!`, 'bad');
        // Capture officers
        if (conquerorId && gameState.officers) {
            const lostOfficers = gameState.officers.filter(o => o.faction === factionId);
            const conquerorCities = Object.values(gameState.cities).filter(c => c.owner === conquerorId);
            if (conquerorCities.length > 0) {
                for (const off of lostOfficers) {
                    if (Math.random() < 0.6) { // 60% chance to join conqueror
                        off.faction = conquerorId;
                        off.cityId = conquerorCities[0].id;
                        addLog('장수', `${off.name}(이)가 ${FACTIONS[conquerorId].name}에 합류했습니다!`, 'good');
                    }
                }
            }
        }
    }
}

// ============================================================
// MAP VISUALIZATION (attack lines)
// ============================================================

function clearAttackLines() {
    for (const line of attackLines) {
        map.removeLayer(line);
    }
    attackLines = [];
}

function showAttackLines(srcCityId) {
    clearAttackLines();
    const src = gameState.cities[srcCityId];
    const adjacent = ADJACENCY[srcCityId] || [];

    for (const adjId of adjacent) {
        const adj = gameState.cities[adjId];
        if (adj.owner === gameState.playerFaction) continue; // skip own cities
        const isEnemy = adj.owner !== null;
        const color = isEnemy ? '#f44336' : '#ffd700';
        const line = L.polyline(
            [[src.lat, src.lng], [adj.lat, adj.lng]],
            { color, weight: 2, dashArray: '8,6', opacity: 0.7 }
        ).addTo(map);
        attackLines.push(line);
    }
}

function showBattleAnimation(srcCity, dstCity) {
    const line = L.polyline(
        [[srcCity.lat, srcCity.lng], [dstCity.lat, dstCity.lng]],
        { color: '#ff5252', weight: 3, dashArray: '4,8', opacity: 0.9 }
    ).addTo(map);

    let opacity = 0.9;
    const anim = setInterval(() => {
        opacity -= 0.15;
        if (opacity <= 0) {
            clearInterval(anim);
            try { map.removeLayer(line); } catch(e) {}
        } else {
            try { line.setStyle({ opacity }); } catch(e) {}
        }
    }, 80);
}

// ============================================================
// ATTACK UI
// ============================================================

function enterAttackMode(cityId) {
    attackMode = true;
    selectedCityId = cityId;
    showAttackLines(cityId);
    updateCityPanel();
}

function cancelAttackMode() {
    attackMode = false;
    clearAttackLines();
    updateCityPanel();
}

function getAttackTargets(cityId) {
    const adjacent = ADJACENCY[cityId] || [];
    return adjacent
        .map(id => gameState.cities[id])
        .filter(c => c && c.owner !== gameState.playerFaction);
}

function selectAttackTarget(srcCityId, dstCityId) {
    const src = gameState.cities[srcCityId];
    const dst = gameState.cities[dstCityId];
    clearAttackLines();

    // Show line to selected target
    const color = dst.owner ? '#f44336' : '#ffd700';
    const line = L.polyline(
        [[src.lat, src.lng], [dst.lat, dst.lng]],
        { color, weight: 3, dashArray: '6,4', opacity: 0.9 }
    ).addTo(map);
    attackLines.push(line);

    // Show troop slider in panel
    showTroopSlider(srcCityId, dstCityId);
}

function showTroopSlider(srcCityId, dstCityId) {
    const src = gameState.cities[srcCityId];
    const dst = gameState.cities[dstCityId];
    const maxTroops = src.troops;
    const minTroops = Math.min(1000, maxTroops);
    const dstOwnerName = dst.owner ? FACTIONS[dst.owner].name : '공백지';
    const dstColor = dst.owner ? FACTIONS[dst.owner].color : '#888';
    const defaultTroops = Math.max(minTroops, Math.floor(maxTroops * 0.5));

    const cityInfo = document.getElementById('city-info');
    cityInfo.innerHTML = `
        <h3>출병: ${src.korean} → ${dst.korean}</h3>
        <div class="city-owner" style="color:${dstColor}">대상: ${dstOwnerName} | 병력 ${formatNum(dst.troops)}</div>

        <div class="troop-slider-section">
            <label>출병 병력 선택</label>
            <input type="range" id="troop-slider" min="${minTroops}" max="${maxTroops}" value="${defaultTroops}" step="500"
                oninput="document.getElementById('slider-val').textContent=formatNum(parseInt(this.value))">
            <div class="slider-info">
                <span>최소 ${formatNum(minTroops)}</span>
                <span id="slider-val" style="color:#ff8a80;font-weight:bold;font-size:13px;">${formatNum(defaultTroops)}</span>
                <span>최대 ${formatNum(maxTroops)}</span>
            </div>
            <div style="margin-top:6px;font-size:10px;color:#888;">잔류 병력: <span id="remain-display">${formatNum(maxTroops - defaultTroops)}</span></div>
        </div>

        <button class="confirm-attack-btn" onclick="executeAttack('${srcCityId}','${dstCityId}')">⚔ 출병 확인</button>
        <button class="cancel-attack-btn" onclick="cancelAttackMode()">취소</button>
    `;

    // Live update remain display
    const slider = document.getElementById('troop-slider');
    slider.addEventListener('input', () => {
        const remain = maxTroops - parseInt(slider.value);
        document.getElementById('remain-display').textContent = formatNum(remain);
    });
}

function executeAttack(srcCityId, dstCityId) {
    const src = gameState.cities[srcCityId];
    const dst = gameState.cities[dstCityId];
    const slider = document.getElementById('troop-slider');
    if (!slider) return;
    const attackTroops = parseInt(slider.value);

    if (!attackTroops || attackTroops < 1000 || attackTroops > src.troops) return;

    attackMode = false;
    clearAttackLines();

    // Consume 1 action
    src.actionsLeft--;

    // Resolve battle IMMEDIATELY (not inside animation callback)
    const isBloodless = !dst.owner || dst.troops <= 0;
    const result = resolveBattle(attackTroops, dst, srcCityId, dstCityId);
    const dstOwnerName = dst.owner ? FACTIONS[dst.owner].name : '공백지';

    applyBattleResult(src, dst, attackTroops, result, gameState.playerFaction, srcCityId);

    // Play animation (purely visual, non-blocking)
    try { showBattleAnimation(src, dst); } catch(e) {}

    // Show battle popup
    showBattlePopup(src, dst, attackTroops, result, dstOwnerName, isBloodless);

    // Log
    if (isBloodless) {
        addLog(src.korean, `→ ${dst.korean} 무혈 점령! (병력 ${formatNum(result.attRemain)} 주둔)`, 'good');
    } else if (result.victory) {
        addLog(src.korean, `→ ${dst.korean} 공격 승리! (아군 손실: ${formatNum(result.attLoss)}, 적 손실: ${formatNum(result.defLoss)})`, 'good');
    } else {
        addLog(src.korean, `→ ${dst.korean} 공격 패배... (공격군 ${formatNum(attackTroops)} 전멸)`, 'bad');
    }

    recalcFactions();
    updateAllUI();
    checkVictory();
    checkGameOver();
}

function showBattlePopup(src, dst, attackTroops, result, dstOwnerName, isBloodless) {
    const popup = document.getElementById('battle-popup');
    const box = document.getElementById('battle-box');

    if (isBloodless) {
        box.className = 'battle-box victory';
        box.innerHTML = `
            <h2 style="color:#ffd700;">⚔ 무혈 점령!</h2>
            <div class="battle-detail">
                <div><span class="att">${src.korean}</span> → <span class="def">${dst.korean}</span></div>
                <div>주둔 병력: <span class="att">${formatNum(result.attRemain)}</span></div>
            </div>
            <button onclick="closeBattlePopup()">확인</button>
        `;
    } else if (result.victory) {
        box.className = 'battle-box victory';
        box.innerHTML = `
            <h2 style="color:#ffd700;">⚔ 승리!</h2>
            <div class="battle-detail">
                <div><span class="att">${src.korean}</span> (${FACTIONS[gameState.playerFaction].name}) → <span class="def">${dst.korean}</span> (${dstOwnerName})</div>
                <div>공격 병력: <span class="att">${formatNum(attackTroops)}</span> → 손실: <span class="att">-${formatNum(result.attLoss)}</span> | 잔여: <span class="att">${formatNum(result.attRemain)}</span></div>
                <div>수비 병력: <span class="def">${formatNum(result.defLoss + result.defRemain)}</span> → 손실: <span class="def">-${formatNum(result.defLoss)}</span></div>
                <div style="margin-top:4px;color:#ffd700;">도시 점령 완료! 주둔: ${formatNum(result.attRemain)}</div>
            </div>
            <button onclick="closeBattlePopup()">확인</button>
        `;
    } else {
        box.className = 'battle-box';
        box.innerHTML = `
            <h2 style="color:#f44336;">⚔ 패배...</h2>
            <div class="battle-detail">
                <div><span class="att">${src.korean}</span> (${FACTIONS[gameState.playerFaction].name}) → <span class="def">${dst.korean}</span> (${dstOwnerName})</div>
                <div>공격 병력: <span class="att">${formatNum(attackTroops)}</span> → <span class="att" style="color:#f44336;">전멸</span></div>
                <div>수비 병력 잔여: <span class="def">${formatNum(result.defRemain)}</span></div>
            </div>
            <button onclick="closeBattlePopup()">확인</button>
        `;
    }

    popup.classList.add('active');
}

function closeBattlePopup() {
    document.getElementById('battle-popup').classList.remove('active');
}

// ============================================================
// AI COMBAT
// ============================================================

function processAICombat() {
    for (const [fid, faction] of Object.entries(FACTIONS)) {
        if (fid === gameState.playerFaction) continue;
        if (gameState.eliminated.includes(fid)) continue;

        const myCities = Object.values(gameState.cities).filter(c => c.owner === fid);
        for (const city of myCities) {
            if (city.troops <= 8000) continue;

            const targets = (ADJACENCY[city.id] || [])
                .map(id => gameState.cities[id])
                .filter(c => c && c.owner !== fid);

            if (targets.length === 0) continue;

            // Prioritize: empty cities first, then weak enemies (< 3000 troops)
            const emptyTargets = targets.filter(t => !t.owner || t.troops <= 0);
            const weakTargets = targets.filter(t => t.owner && t.troops > 0 && t.troops < 3000);

            let target = null;
            if (emptyTargets.length > 0) {
                target = emptyTargets[Math.floor(Math.random() * emptyTargets.length)];
            } else if (weakTargets.length > 0) {
                // Pick weakest
                weakTargets.sort((a, b) => a.troops - b.troops);
                target = weakTargets[0];
            }

            if (!target) continue;

            // Keep at least 2000 troops in city
            const maxSend = city.troops - 2000;
            if (maxSend < 1000) continue;
            const sendTroops = Math.min(maxSend, Math.max(3000, Math.floor(city.troops * 0.6)));

            const isBloodless = !target.owner || target.troops <= 0;
            const result = resolveBattle(sendTroops, target, city.id, target.id);
            const targetOwnerName = target.owner ? FACTIONS[target.owner]?.name || '공백지' : '공백지';

            applyBattleResult(city, target, sendTroops, result, fid, city.id);

            if (isBloodless) {
                addLog('전투', `${faction.name}: ${city.korean} → ${target.korean} 무혈 점령`, 'info');
            } else if (result.victory) {
                addLog('전투', `${faction.name}: ${city.korean} → ${target.korean}(${targetOwnerName}) 공격 승리!`, 'info');
            } else {
                addLog('전투', `${faction.name}: ${city.korean} → ${target.korean}(${targetOwnerName}) 공격 패배`, 'info');
            }
        }
    }
}

// ============================================================
// VICTORY / DEFEAT
// ============================================================

function checkVictory() {
    const allOwned = Object.values(gameState.cities).every(c => c.owner === gameState.playerFaction);
    if (allOwned) {
        showVictoryScreen(true);
    }
}

function checkGameOver() {
    const playerCities = Object.values(gameState.cities).filter(c => c.owner === gameState.playerFaction);
    if (playerCities.length === 0) {
        showVictoryScreen(false);
    }
}

function showVictoryScreen(isVictory) {
    const overlay = document.getElementById('victory-overlay');
    const box = document.getElementById('victory-box');

    if (isVictory) {
        box.innerHTML = `
            <h1 style="color:#ffd700;">天下統一!</h1>
            <p>${FACTIONS[gameState.playerFaction].name}(이)가 천하를 통일하였습니다!</p>
            <p style="font-size:13px;color:#888;">턴: ${gameState.turn} | ${gameState.year}년 ${gameState.month}월</p>
            <button onclick="location.reload()">타이틀로</button>
        `;
    } else {
        box.innerHTML = `
            <h1 style="color:#f44336;">게임 오버</h1>
            <p>${FACTIONS[gameState.playerFaction].name} 세력이 멸망하였습니다...</p>
            <p style="font-size:13px;color:#888;">턴: ${gameState.turn} | ${gameState.year}년 ${gameState.month}월</p>
            <button onclick="location.reload()">타이틀로</button>
        `;
    }

    overlay.classList.add('active');
}

// ============================================================
// INIT
// ============================================================

initTitleScreen();
</script>
</body>
</html>
